#### Master-Work 模式
Master-Worker 模式是常用的并行计算模式。它的核心思想是系统由两类进程协作工作：Master 进程和 Worker 进程。Master 负责接收和分配任务，Worker 负责处理子任务。当各个 Worker 子进程处理完成后，会将结果返回给 Master , 由 Master 进行归纳和总结。其好处是能将一个大任务分解成若干个小任务，并行执行，从而提高系统的吞吐量。

在Master端往往会有如下的内容：  
1、一个盛放任务的容器，一般使用队列来保证先添加的任务先执行，因为在下面参考文章的例子中，任务在main方法中被直接一口气全部提交过来，所以worker不需要在没有任务可以取的时候而阻塞等待新任务，也就是不牵涉到阻塞，所以在这里推荐使用非阻塞的线程安全队列ConcurrentLinkedQueue性能更好，参考文章中也是使用了这种队列。  
2、一个盛放worker的线程集合，worker就是用来执行任务的，所以就是个子线程，所以可以使用HashMap<String, Thread>来盛放，key是每个worker线程的标识。  
3、一个盛放任务结果的集合，和盛放worker的线程集合不同，worker的线程集合就是在初始化Master时需要指定有多少个worker的，所以是一并初始化好的，没有并发也就没有线程安全问题，而任务结果的集合会被多个worker访问，需要线程安全的容器才行，推荐ConcurrentHashMap。  
每个worker端往往会有如下的内容：  
1、Master里盛放任务的容器的引用，因为需要获取任务。  
2、Master里盛放任务结果集合，因为需要把处理完的任务结果放进去。  